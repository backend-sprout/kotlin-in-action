자바 함수형 인터페이스 활용
===========================    
코틀린 라이브러리와 람다를 사용하는 것은 멋지지만, 대다수 자바 API를 사용할 가능성이 높다.     
다행인점은 코틀린 람다를 자바 API에 사용해도 아무 문제가 없다는 사실이다.     

```java
public class Button {
    public void setOnClickListener(onClickListener l) { 
        ... // 생략  
    }
}
```
```java
public interface OnClickListener {
    void onClick(Viwe v);
}
```
위와 같은 자바 코드가 있다고 가정했을 때에도 코틀린 람다를 사용할 수 있다.   
   
```kt
button.setOnClickListener { view -> /* 생략 */ }    
```  
이런 코드가 동작하는 이유는 OnClickListener에 추상 메서드가 단 하나만 있기 때문이다.         
이런 인터페이스를 **함수형 인터페이스**, 또는 **SAM 인터페이스**라고 부른다.        
SAM은 단일 추상 메서드(Single abstract method)라는 뜻이다.           
코틀린은 함수형 인터페이스를 인자로 취하는 자바 메서드를 호출할 때 람다를 넘길 수 있게 해준다.        

```
자바와 달리 코틀린에는 제대로 된 함수 타입이 존재한다.       
따라서 코틀린에서 함수를 인자로 받을 필요가 있는 함수는        
함수형 인터페이스가 아니라 함수 타입을 인자 타입으로 사용해야한다.        
코틀린 함수를 사용할 때는 코틀린 컴파일러가 코틀린 람다를 함수형 인터페이스로 변환해주지 않는다.       
```

# 자바 메소드에 람다를 인자로 전달  
  
함수형 인터페이스를 인자로 원하는 자바 메소드에 코틀린 람다를 전달할 수 있다.         

```java
void postponeComputation(int delay, Runnable computation);
```
코틀린에서 람다를 이 함수에 넘길 수 있다.       
컴파일러는 자동으로 람다를 Runnable 인스턴스로 변환해준다.      

```kt
postponeComputation(1000) { println(42) }
```
위와 같이 람다를 이용해서 사용할 수 있다.   

```kt
postponeComputation(1000, object: Runnable {
    override fun run() {
        pinrln(42)
    }
})
```
위와 같이 익명 객체를 사용해도 된다.   

```kt
postponeComputation(1000) { println(42) } // 프로그램 전체에서 Runnable와 인스턴스는 단 하나만 만들어진다.   
```
중요한 이야기이지만, 람다와 익명 객체 사이에는 차이가 있다.        
객체를 명시적으로 선언하는 경우 메서드를 호출할 때 마다 새로운 객체가 생성된다.      
람다는 무명 객체를 메서드를 호출할 때마다 반복 사용한다.     

```kt
val runnable = Runnable { println(42) }
fun handleComputation() {
    postponeComputation(1000, runnable)
}
```
따라서 명시적인 object 선언을 사용하면서 람다와 동일한 코드는 위와 같다.       
이 경우 Runnable 인스턴스를 변수에 저장하고 메서드를 호출할 때마다 그 인스턴스를 사용한다.     

```kt
fun handleComputation(id: String) {                 // id를 포획한다.     
    postponeComputation(1000) { println(id) }       // 호출할 때마다 새로운 인스턴스 객체 생성 
}
```
람다가 주변 영역의 변수를 포획한다면 매 호출마다 같은 인스턴스를 사용할 수는 없다.    
그런 경우 컴파일러는 매번 주변 영역의 변수를 포획한 새로운 인스턴스를 생성해준다.     

# 번외 
참고로, 필자가 일부러 제외시킨 내용이 있는데 람다는 익명 객체와는 다르다.              
람다를 사용하게 되면 `return 문`을 제외시킬 수 있는 것으로 미루어보아 익명 함수라고는 부를 수 있다.       
   
이 부분에 대해서 보다 정확히 말을 하자면,      
자바에서의 람다는 INDY로 변환하고, 코틀린에서의 람다는 익명클래스로 변환을 한다.   
  
## 자바 람다 VS 코틀린 람다 
자바의 익명 클래스를 컴파일 했을 경우, `상위클래스$1`과 같은 형태로 컴파일 되지만 람다는 그렇지 않다.          
즉, 익명 클래스는 `상위클래스$1`로 컴파일 되고 이 안에서 메서드를 호출하는 형식이다.(함수형 인터페이스 참조)   
이는 곧 아래와 같은 문제를 이야기 한다.  

* 항상 새 인스턴스로 할당한다
* 람다식 마다 클래스가 하나씩 생기게된다

자바에서의 람다는 클래스가 아니라 `private static 메서드`를 만들어서 실행을 한다.          
이 과정에서 `INVOKEDYNAMIC CALL`가 발생하는데 쉽게 설명해서 `객체 생성 방법을 정의` + `재호출` 과정을 진행한다.       
즉, 앞서 언급했던 **코틀린의 포획 변수가 없는 람다와 비슷한 동작을 한다고 생각하면 된다.**       
참고로 코틀린의 람다는 익명 클래스로 변환되는 작업이 있기에 위와 같은 차이점이 있다고 언급한 것이다.        
     
이 외에도 Variable Capture 랑 관련된 내용이 나오는데         
이 부분도 코틀린에서는 변경 가능한 변수를 우회하여 사용 가능한 반면에        
자바는 유사적 final 한 변수만을 접근 할 수 있다는 차이점이 있다.    

## 실험 요소   
> 지금 당장은 아닌데 해보면 좋을 것   

자바 익명함수 vs 람다 컴파일시 바이트 코드 확인     
코틀린 익명함수 vs 람다 컴파일시 바이트 코드 확인     
  
코틀린 1.0, 1.1 에서는 아직 익명 클래스로 변환하는 로직을 사용해서 매번 클래스 파일을 생성한다고 언급한다.          
그리고 차후에 자바8 바이트코드 방식으로 변환한다는데, 현재 kotlin 1.5 버전으로 개선되었을 가능성이 높다.      
그러므로 1시간만 투자해서 결과를 얻어내는 작업을 진행해보자.    















