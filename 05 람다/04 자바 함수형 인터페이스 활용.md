자바 함수형 인터페이스 활용
===========================    
코틀린 라이브러리와 람다를 사용하는 것은 멋지지만, 대다수 자바 API를 사용할 가능성이 높다.     
다행인점은 코틀린 람다를 자바 API에 사용해도 아무 문제가 없다는 사실이다.     

```java
public class Button {
    public void setOnClickListener(onClickListener l) { 
        ... // 생략  
    }
}
```
```java
public interface OnClickListener {
    void onClick(Viwe v);
}
```
위와 같은 자바 코드가 있다고 가정했을 때에도 코틀린 람다를 사용할 수 있다.   
   
```kt
button.setOnClickListener { view -> /* 생략 */ }    
```  
이런 코드가 동작하는 이유는 OnClickListener에 추상 메서드가 단 하나만 있기 때문이다.         
이런 인터페이스를 **함수형 인터페이스**, 또는 **SAM 인터페이스**라고 부른다.        
SAM은 단일 추상 메서드(Single abstract method)라는 뜻이다.           
코틀린은 함수형 인터페이스를 인자로 취하는 자바 메서드를 호출할 때 람다를 넘길 수 있게 해준다.        

```
자바와 달리 코틀린에는 제대로 된 함수 타입이 존재한다.       
따라서 코틀린에서 함수를 인자로 받을 필요가 있는 함수는        
함수형 인터페이스가 아니라 함수 타입을 인자 타입으로 사용해야한다.        
코틀린 함수를 사용할 때는 코틀린 컴파일러가 코틀린 람다를 함수형 인터페이스로 변환해주지 않는다.       
```

# 자바 메소드에 람다를 인자로 전달  
  
함수형 인터페이스를 인자로 원하는 자바 메소드에 코틀린 람다를 전달할 수 있다.         

```java
void postponeComputation(int delay, Runnable computation);
```
코틀린에서 람다를 이 함수에 넘길 수 있다.       
컴파일러는 자동으로 람다를 Runnable 인스턴스로 변환해준다.      

```kt
postponeComputation(1000) { println(42) }
```
위와 같이 람다를 이용해서 사용할 수 있다.   

```kt
postponeComputation(1000, object: Runnable {
    override fun run() {
        pinrln(42)
    }
})
```
위와 같이 익명 객체를 사용해도 된다.   

```kt
postponeComputation(1000) { println(42) } // 프로그램 전체에서 Runnable와 인스턴스는 단 하나만 만들어진다.   
```
중요한 이야기이지만, 람다와 익명 객체 사이에는 차이가 있다.        
객체를 명시적으로 선언하는 경우 메서드를 호출할 때 마다 새로운 객체가 생성된다.      
람다는 무명 객체를 메서드를 호출할 때마다 반복 사용한다.     

```kt
val runnable = Runnable { println(42) }
fun handleComputation() {
    postponeComputation(1000, runnable)
}
```
따라서 명시적인 object 선언을 사용하면서 람다와 동일한 코드는 위와 같다.       
이 경우 Runnable 인스턴스를 변수에 저장하고 메서드를 호출할 때마다 그 인스턴스를 사용한다.     

```kt
fun handleComputation(id: String) {                 // id를 포획한다.     
    postponeComputation(1000) { println(id) }       // 호출할 때마다 새로운 인스턴스 객체 생성 
}
```
람다가 주변 영역의 변수를 포획한다면 매 호출마다 같은 인스턴스를 사용할 수는 없다.    
그런 경우 컴파일러는 매번 주변 영역의 변수를 포획한 새로운 인스턴스를 생성해준다.     

람다에 대해 무명 클래스를 만들고 그 클래스의 인스턴스를 만들어서 메서드에 넘긴다는 설명은       
함수형 인터페이스를 받는 자바 메서드를 코틀린에서 호출할 때 쓰는 방식을 설명해주지만,         
**컬렉션을 확장한 메서드에 람다를 넘기는 경우 코틀린은 그런 방식을 사용하지 않는다.**     
대부분의 확장 함수는 `inline`표시가 붙어있는데 이 함수에 람다를 넘기면 아무런 무명 클래스가 만들어지지 않는다.      

```
/// 인라인
컴파일 과정에서 원래 함수로 따로 분리되어 있던 것이   
최종 컴파일된 코드에서는 함수를 호출하는 위치에 함수의 본문이 삽입되어 프로그램을 최적화해주는 테크닉입니다.
```
  
# SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경     


# 번외 
참고로, 필자가 일부러 제외시킨 내용이 있는데 람다는 익명 객체와는 다르다.              
람다를 사용하게 되면 `return 문`을 제외시킬 수 있는 것으로 미루어보아 익명 함수라고는 부를 수 있다.       
   
이 부분에 대해서 보다 정확히 말을 하자면,      
자바에서의 람다는 INDY로 변환하고, 코틀린에서의 람다는 익명클래스로 변환을 한다.   
  
## 자바 람다 VS 코틀린 람다 
자바의 익명 클래스를 컴파일 했을 경우, `상위클래스$1`과 같은 형태로 컴파일 되지만 람다는 그렇지 않다.          
즉, 익명 클래스는 `상위클래스$1`로 컴파일 되고 이 안에서 메서드를 호출하는 형식이다.(함수형 인터페이스 참조)   
이는 곧 아래와 같은 문제를 이야기 한다.  

* 항상 새 인스턴스로 할당한다
* 람다식 마다 클래스가 하나씩 생기게된다

자바에서의 람다는 클래스가 아니라 `private static 메서드`를 만들어서 실행을 한다.          
이 과정에서 `INVOKEDYNAMIC CALL`가 발생하는데 쉽게 설명해서 `객체 생성 방법을 정의` + `재호출` 과정을 진행한다.       
즉, 앞서 언급했던 **코틀린의 포획 변수가 없는 람다와 비슷한 동작을 한다고 생각하면 된다.**       
참고로 코틀린의 람다는 익명 클래스로 변환되는 작업이 있기에 위와 같은 차이점이 있다고 언급한 것이다.        
     
이 외에도 Variable Capture 랑 관련된 내용이 나오는데         
이 부분도 코틀린에서는 변경 가능한 변수를 우회하여 사용 가능한 반면에        
자바는 유사적 final 한 변수만을 접근 할 수 있다는 차이점이 있다.    

## 실험 요소   
> 지금 당장은 아닌데 해보면 좋을 것     
> 윙님 블로그(아이디어 떠오르게 해주심) : https://sujl95.tistory.com/76   
> https://www.baeldung.com/java-invoke-dynamic      
> https://tourspace.tistory.com/11   

자바 익명함수 vs 람다 컴파일시 바이트 코드 확인     
코틀린 익명함수 vs 람다 컴파일시 바이트 코드 확인     
  
코틀린 1.0, 1.1 에서는 아직 익명 클래스로 변환하는 로직을 사용해서 매번 클래스 파일을 생성한다고 언급한다.          
그리고 차후에 자바8 바이트코드 방식으로 변환한다는데, 현재 kotlin 1.5 버전으로 개선되었을 가능성이 높다.      
그러므로 1시간만 투자해서 결과를 얻어내는 작업을 진행해보자.    

```
// 람다의 자세한 구현 

코틀린 1.0에서 인라인 되지 않은 모든 람다 식은 무명 클래스로 컴파일 된다.     
코틀린 1.1에서부터는 자바 8 바이트 코드를 생성할 수 있지만 여전히 코틀린 1.0처럼 람다마다 별도의 클래스를 만들어낸다.      
하지만 향후 별도의 클래스를 만들지 않고 자바 8부터 도입된 람다 기능(INDY)를 활용한 바이트코드를 만들어낼 계획이다.       
참고 : https://kotlinlang.org/docs/whatsnew15.html#lambdas-via-invokedynamic   
코틀린 1.5.0 부터 지원을 시작한 것 같다!! 

람다가 변수를 포획하면 무명 클래스 안에 포획한 벼수를 저장하는 필드가 생기며,   
매 호출마다 그 무명 클래스의 인스턴스를 새로 만든다.   
하지만 포획하는 변수가 없는 람다에 대해서는 인스턴스가 단 하나만 생긴다.    
'HandleComputation$1'처럼 람다가 선언된 함수 이름을 접두사로 하는 이름이 람다를 컴파일한 클래스에 붙는다.   

다음은 앞에 살펴본(포획이 있는) 람다 식의 바이트코드를 디컴파일하면 볼 수 있는 코드다.    

class HandleComputation$1 (val id: String) : Runnable {
    override fun run() {
        println(id)
    }
}

fun handleComputation(id: String) {
    postponeComputation(1000, HandleComputation$1(id))
}

코드를 보면 알 수 있지만 컴파일러는 포획한 변수마다 그 값을 저장하기 위한 필드를 만든다.   
```  













