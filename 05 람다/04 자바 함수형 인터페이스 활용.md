자바 함수형 인터페이스 활용
===========================    
코틀린 라이브러리와 람다를 사용하는 것은 멋지지만, 대다수 자바 API를 사용할 가능성이 높다.     
다행인점은 코틀린 람다를 자바 API에 사용해도 아무 문제가 없다는 사실이다.     

```java
public class Button {
    public void setOnClickListener(onClickListener l) { 
        ... // 생략  
    }
}
```
```java
public interface OnClickListener {
    void onClick(Viwe v);
}
```
위와 같은 자바 코드가 있다고 가정했을 때에도 코틀린 람다를 사용할 수 있다.   
   
```kt
button.setOnClickListener { view -> /* 생략 */ }    
```  
이런 코드가 동작하는 이유는 OnClickListener에 추상 메서드가 단 하나만 있기 때문이다.         
이런 인터페이스를 **함수형 인터페이스**, 또는 **SAM 인터페이스**라고 부른다.        
SAM은 단일 추상 메서드(Single abstract method)라는 뜻이다.           
코틀린은 함수형 인터페이스를 인자로 취하는 자바 메서드를 호출할 때 람다를 넘길 수 있게 해준다.        

```
자바와 달리 코틀린에는 제대로 된 함수 타입이 존재한다.       
따라서 코틀린에서 함수를 인자로 받을 필요가 있는 함수는        
함수형 인터페이스가 아니라 함수 타입을 인자 타입으로 사용해야한다.        
코틀린 함수를 사용할 때는 코틀린 컴파일러가 코틀린 람다를 함수형 인터페이스로 변환해주지 않는다.       
```

# 자바 메소드에 람다를 인자로 전달  
  
함수형 인터페이스를 인자로 원하는 자바 메소드에 코틀린 람다를 전달할 수 있다.         

```java
void postponeComputation(int delay, Runnable computation);
```
코틀린에서 람다를 이 함수에 넘길 수 있다.       
컴파일러는 자동으로 람다를 Runnable 인스턴스로 변환해준다.      

```kt
postponeComputation(1000) { println(42) }
```
위와 같이 람다를 이용해서 사용할 수 있다.   

```kt
postponeComputation(1000, object: Runnable {
    override fun run() {
        pinrln(42)
    }
})
```
위와 같이 익명 객체를 사용해도 된다.   

```kt
postponeComputation(1000) { println(42) } // 프로그램 전체에서 Runnable와 인스턴스는 단 하나만 만들어진다.   
```
중요한 이야기이지만, 람다와 익명 객체 사이에는 차이가 있다.        
객체를 명시적으로 선언하는 경우 메서드를 호출할 때 마다 새로운 객체가 생성된다.      
람다는 무명 객체를 메서드를 호출할 때마다 반복 사용한다.     

```kt
val runnable = Runnable { println(42) }
fun handleComputation() {
    postponeComputation(1000, runnable)
}
```
따라서 명시적인 object 선언을 사용하면서 람다와 동일한 코드는 위와 같다.       
이 경우 Runnable 인스턴스를 변수에 저장하고 메서드를 호출할 때마다 그 인스턴스를 사용한다.     

```kt
fun handleComputation(id: String) {                 // id를 포획한다.     
    postponeComputation(1000) { println(id) }       // 호출할 때마다 새로운 인스턴스 객체 생성 
}
```
람다자 주변 영역의 변수를 포획한다면 매 호출마다 같은 인스턴스를 사용할 수는 없다.    
그런 경우 컴파일러는 매번 주변 영역의 변수를 포획한 새로운 인스턴스를 생성해준다.     










