클래스 계층 정의
=============
> 코틀린에서 클래스 계층을 정의하는 방식과 자바 방식을 비교한다.       
> 그 후 코틀린의 가시성과 접근 변경자에 대해 살펴본다.         
  
코틀린 가시성/접근 변경자는 자바와 비슷하지만, 아무것도 지정하지 않은 경우 기본 가시성은 다르다.      
또한 코틀린에서 새로 도입한 sealed 변경자에 대해 설명한다.(sealed는 클래스 상속을 제어한다.)       
   
# 코틀린 인터페이스   
코틀린 인터페이스는 자바8 인터페이스와 비슷하다.     
코틀린 인터페이스 안에는 추상 메서드뿐 아니라 구현이 있는 메서드도 정의할 수 있다.(자바의 디폴트 메서드)          
다만 인터페이스에는 아무런 상태도 들어갈 수 없다.(인스턴스 변수)    

```kt
interface Clickable {
    fun click()
}
```
click() 추상 메서드를 정의한 인터페이스다.     

```kt
class Button: Clickable {
    override fun click() = println("I was clicked")
}
```
```kt
Button().click()
>>> I was clicked   
```  
코틀린에서는 `: 상위 타입`을 붙이는 것으로 상속과 구현 모두 지원한다.           
이외에 비슷한 점으로 자바처럼 단일 상속, 다중 구현을 지원한다.          

참고로 자바의 `@Override` 대신에 `override`변경자를 사용하여 프로퍼티나 메서드를 오버라이드한다.   
그리고 이러한 변경자는 생략 불가능하므로 꼭 사용해야 한다.(실수를 방지해준다.)   

```kt
interface Clickable {
    fun click()                               // 일반 추상 메서드 
    fun showOff() = println("I'm clickable!") // 디폴트 구현이 있는 메서드 
}
```   
인터페이스 메서드도 디폴트 구현을 제공할 수 있다.      
이 경우 **자바와 다르게 `default`키워드를 붙이지 않고 그냥 정의하기만 하면 된다.**        

인터페이스 구현 클래스는 `click()`에 대한 메서드 정의는 필수지만,   
`showOff()`에 대한 오버라이딩은 선택적이다.        
     
```kt
interface Focusable {
    fun setFocus(b: Boolean) = println("I ${if (b) "got" else "lost"} focus.")
    fun showOff = println("I'm focusable!")
}
```
만약, 동일한 이름을 가진 메서드를 다른 인터페이스에서도 정의했다고 가정하자.    
     
**한 클래스에서 이 두 인터페이스를 함께 구현하면 어떻게 될까? 🤔**          
정답은 바로... 어느 쪽도 선택되지 않는다.         
클래스가 구현하는 두 상위 인터페이스에 정의된 showOff() 구현을 대체한        
오버라이딩 메서드를 직접 제공하지 않으면 컴파일 오류가 발생한다.(사실 자바도 똑같다)           

```
The class 'Button' must 
override public open fun showOff() because it inhreits  
many implementations of it.
```
코틀린 컴파일러는 두 메서드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.    

```kt
class Button: Clickable, Focusable {
    override fun click() = println("I was clicked")
    override fun showOff() {        // 시그니처가 같은 멤버 메서드에 대해 둘 이상의 디폴트 구현이 있는 경우 필히 오버라이딩 해야한다.
        super<Clickable>.showOff()  // 상위 타입의 이름을 꺾쇠 <> 사이에 넣어서 super를 지정하면      
        super<Focusable>.showOff()  // 어떤 상위 타입의 멤버 메서드를 특정하여 호출할 수 있다.      
    }
}
```
시그니처가 같은 멤버 메서드에 대해 둘 이상의 디폴트 구현이 있는 경우 필히 오버라이딩 해야한다.          
일반적인 상태에서 상위 타입을 호출하고자 하면 단순히 `super`를 사용하면 된다.            
그러나 둘 이상의 상위 타입이 존재할 경우 `super<상위타입>`을 이용하여 명시적으로 선택할 수 있다.         
단, 이 같은 경우도 상위 타입 메서드를 사용할 경우이지, 새롭게 오버라이딩한다면 굳이 정의할 필요는 없다.    
참고로 자바에서는 `Clickable.super.showOff`, `Focusable.super.showOff`와 같은 방식으로 접근한다.      

```kt
override fun showOff() = super<Clickable>.showOff()    
```
하나의 상위 타입만 사용할 경우라면 위와 같이 작성해도 된다.   

```kt

```






    

