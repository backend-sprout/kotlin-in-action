object 키워드: 클래스 선언과 인스턴스 생성
===================================
코틀린의 object 키워드는 다양한 상황에서 사용하지만     
모든 경우 클래스를 정의하면서 동시에 인스턴를 생성한다는 공통점이 있다.     
  
* **객체 선언**은 싱글턴을 정의하는 방법 중 하나이다.  
* **동반 객체**는 인스턴스 메서드는 아니지만 어떤 클래스와 관련 있는 메서드와 팩토리 메서드를 담을 때 사용한다.   
    동반 객체 메서드에 접근할 때는 포함된 클래스의 이름을 사용할 수 없다.    
* 객체 식은 코틀린의 특성에 대해 자세히 설명한다.   

# 객체 선언
객체지향 시스템을 설계하다 보면 인스턴스가 하나만 필요한 클래스가 유용한 경우가 많다.       
**코틀린은 객체 선언 기능을 통해 싱글턴을 언어에서 기본 지원한다.**     
객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다.(스레드 세이프하려나?)     

```kt
object Payroll {
    val allEmployee = arrayListOf<Person>()
    fun calculateSalary() {
        for(person in allEmployee) {
            //
        }
    }
}
```
`객체 선언`은 **object 키워드로 시작한다.**     
`객체 선언`은 클래스를 정의하고 인스턴스를 만들어서 변수에 저장하는 모든 작업을 단 한 문장으로 처리한다.        
(싱글톤 초기화는 스레드 세이프한가? 에 대한 주제는 생각해봐야할 듯, [사이트](https://stackoverflow.com/questions/35587652/kotlin-thread-safe-native-lazy-singleton-with-parameter))      
   
일반 클래스와 마찬가지로 프로퍼티, 메서드, 초기화 블록등이 들어 갈 수 있다.      
하지만 생성자는 객체 선언에 사용할 수 없다.       
싱글턴 객체는 `객체 선언`문이 있는 위치에서 생성자 호출 없이 즉시 만들어진다.(객체 생성 불필요)      

```kt
fun main() {
    Payroll.allEmployee.add(Person())
    Payroll.calculateSalary()
}
```
변수와 마찬가지로 객체 선언에 사용한 이름 뒤에 마침표,를 붙이면 객체에 속한 메서드나 프로퍼티에 접근할 수 있다.   







# 동반 객체  
# 객체 식 
