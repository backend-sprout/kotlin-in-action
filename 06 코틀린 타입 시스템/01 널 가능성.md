널 가능성
=========
널 가능성은 `NullPointerException`오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.              
코틀린을 비롯한 최신 언어에서 null에 대해서 최대한 컴파일 타임에서 검증하는 것으로 목표로하고 있다.       
null 여부를 타입 시스템에 추가함으로써 미리 감지해서 런타임 시점에 발생할 수 있는 예외를 최대한 줄이고자 한다.       
    
# 널이 될 수 있는 타입 
코틀린 타입 시스템은 널이 될 수있는 타입을 명시적으로 지원한다.        
즉, 널이 될 수 있는 타입은 **프로그램 안의 프로퍼티나 변수에 null을 허용하게 만든다는 것이다.**         
이는 곧, **명시적으로 선언하지 않으면 null을 허용하지 않는다는 의미이다.**     

**자바 코드**
```java
int strLen(String s) {
    return a.length();
}
```
위 자바 코드에서 null을 넘기면 예외가 발생한다.       
그렇기 때문에 null과 관련된 예외처리를 작성해야하고 이는 메인 로직을 벗어난 부가 로직이다.      
   
**코틀린 코드**   
```kt
fun strLen(s: String) = s.length   
```  
코틀린에서 함수를 작성할 때 가장 먼저 답을 알아야할 질문은 `이 함수가 null 을 인자로 받을 수 있는가?`이다.         
위 코드에서는 null이거나 null이 될 수 있는 인자를 넘기는 것은 금지되며, 만약 그런값을 넘기면 컴파일 오류가 발생한다.       

```kt
strLen(null)
>>> ERROR: Null can not be a value of a non-null type String
```
부가 설명을 하자면 메서드의 타입은 String인데, 따로 타입으로 지정된 null이 들어와서 컴파일 오류가 발생하는 것이다.    

```kt
fun strLen(s: String?) = s.length   
```
만약 null을 허용하고 싶다면 파라미터 뒤에 `?`를 명시하면 된다.          
어떤 타입이든 타입 이름 뒤에 물음표를 붙이면, 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다는 뜻이다.      
   
```kt
fun strLenSafe(s: String?) = s.length() // 널이 가능한 변수 s에 대해 length() 호출하면서 문제 
>>> ERROR: only safe(?.) or non-null asserted(!!.)  
calls are allowed on a nullable receiver of type kotlin.String?  
```
널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다.   
예를 들면, 널이 될 수 있는 타입인 변수에 대해 `변수.메소드()`처럼 메서드를 직접 호출할 수는 없다.   

```kt
val x: String? = null  
var y: String = x 
>>> ERROR: Type mismatch: inferred type is String? but String was expected
```
널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다.   

```kt
fun strLen(s: String) = s.length   

fun main() {
    val x: String? = null
    strLen(x)
}
>>> ERROR: Type mismatch: inferred type is String? but String was expected
```
널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.       
   
**이런 제약이 많다면 널이 될 수 있는 타입의 값으로 대체 뭘 할 수 있을까? 🤔**        
`널이 될 수 있거나 널인 값`에 대해서 validation을 강제할 수 있다.           
`널이 될 수 있거나 널인 값`에 대해서 `==`를 통해 검증을 수행하면     
컴파일러는 null이 아님이 확실한 영역에서는 해당 값을 널이 될 수 없는 타입의 값처럼 인식한다.   

```kt
fun strLenSafe(s: String?) Int = 
    if (s != null) s.length else 0

fun main() {
    val x: String? = null
    println(strLenSafe(x))
    println(strLenSafe("abc"))
}
>>> 0
>>> 3
```
널 검사를 진행하고 나면, 해당 변수는 널 세이프티가 보장된다.    
    
# 타입의 의미  
**타입이란 무엇이고 왜 변수에 타입을 지정해야 하는걸까? 🤔**   
위키피디아에서는 타입을 아래와 같이 정의했다.   

```
타입은 분류로... 타입은 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.   
```  
특정 타입은 서로간의 타입이 일치한다면 연산이 가능하다.     
double은 다른 double 타입과 연산이 가능하고, String도 다른 String과 덧셈 연산이 가능한 것처럼 말이다.        
그러나 자바에서의 null은 instanceof를 실행했을때 double도 String도 아니라고 나온다.        
이는 곧 null은 다른 종류의 타입과는 완전히 별개이고 연산도 안 된다는 것을 알 수 있다.         

```
// NullPointerException 오류를 다루는 다른 방법   
```
코틀린의 널이 될 수 있는 타입은 이런 문제에 대해 종합적인 해법을 제공한다.         
널이 될 수 있는 타입과 널이 될 수 없는 타입을 구분하면         
각 타입의 값에 대해 어떤 연산이 가능할지 명확히 이해할 수 있고,       
실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있다.         
따라서 그런 연산을 아에 금지시킬 수 있다.       

```
실행 시멎에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다.      
널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다.      
모든 검사는 컴파일 시점에 수행된다.      
따라서 코틀린에서는 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비용이 들지 않는다.     
```

# 안전한 호출 연산자: ?.
안전한 호출 연산자 `?.`은 null 검사와 메서드 호출을 한번의 연산으로 수행한다.(== null 대신 사용 가능)         
`s?.toUpperCase()`는 `if(s != null) s.toUpperCase() else null`과 같다.        
즉, 호출하려는 값이 null이 아닌 경우에는 `?.`는 일반 메소드 호출처럼 작동한다.         
단, 주의점으로 호출하려는 값이 null일 경우 null을 그대로 다시 반환한다는 점을 기억하자.    

```kt
fun printAllCaps(s: String?) {
    val allCaps: String? = s?.toUpperCase() // allCaps는 널이 될 수도 있다.   
    println(allCaps)
}
fun main() {
    pritnAllCaps("abc")
    printAllCpas(null)
}
>>> ABC
>>> null
```
`?.`는 null을 반환할 수 있지만 이미 한번 검증을 진행했기에       
**반환된 null에 대해서 별다른 제약 조건이 없어진다.(이는 주의해야할 점이다.)**        

```kt
class Employee(val name: String, val magnaer: Employee?)
fun managerName(employee: Employee): String? = employee.manager?.name   

fun main() {
    val ceo = Employee("Da Boss", null)
    val developer = Employee("Bob Smith", ceo)
    println(managerName(developer))
    println(managerName(ceo))
}
>> Da Boss
>> null
```
널이 될 수 있는 프로퍼티는 위와 같은 경우에 사용될 수 있다.      

```kt
class Address(val streetAddress: String, val zipCode: Int,
              val city: String, val country: String)
class Company(val name: String, val address: Address?)   
class Person(val name: String, val company: Company?)    

fun Person.countryName(): String {
    val country = this.company?.address?.country        // 여러 안전한 연산자를 연쇄해 사용 가능하다.(디미터는 흠..)
    return if (country != null) country else "Unknown"
}

fun main() {
    val person = Person("Dmitry", null)
    println(person.countryName())
}
>>> Unknown
```
객체 그래프에서 null이 될 수 있는 중간 객체가 여럿 있다면         
한 식 안에서 안전한 호출을 연쇄해서 함께 사용하면 편할 때가 자주 있다.   

참고로 마지막에 `if (country != null) country else "Unknown"`를 통해   
null인 경우에 대응하는 `"Unknown"`을 반환하고 있다.     
그러나 이 로직도 `?:`를 이용하면 쉽게 해결할 수 있다.    
 
# 엘비스 연산자: ?:   

코틀린은 null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 **엘비스 연산자 `?:`** 를 제공한다.        
엘비스 연산자는 `?:`를 시계 방향으로 뒤집으면 엘비스 프레슬리의 헤어스타일과 눈이 보여서 명명된 이름이다.        

```kt
fun foo(s: String?) {
    val t: String = s ?: "" // s가 null이면 결과는 ""이다.  
}   
```  
이 연산자는 **이항 연산자로 좌항을 계산한 값이 널인지 검사한다.**      
**좌항 값이 널이 아니라면 좌항 값을 결과로 하고, 좌항 값이 널이면 우항 값을 결과로 한다.**          
  
```kt    
fun strLenSafe(s: String?): Int = s?.length ?: 0
    
fun main() {
    println(strLenSafe("abc")
    println(strLenSafe(null)
}
>>> 3
>>> 0
```
```kt
fun Person.countryMap() = company?.address?.country ?: "Unkown"
```     
    
엘비스 연산자는 널을 반환하는 안전한 호출 연산자와 함께 사용해서 객체가 널인 경우 대비한 값을 지정하는 경우가 많다.       
      
코틀린에서는 `return` 이나 `throw` 등의 연산도 식이다.           
따라서 **엘비스 연산자의 우항에 `return, throw` 등의 연산을 넣을 수 있고, 엘비스 연산자를 더욱 편하게 사용할 수 있다.**       
이런 패턴은 함수와 전제조건을 검사하는 경우 특히 유용하다.      

```kt
class Address(val streetAddress: String, val zipCode: Int,
              val city: String, val country: String)
class Company(val name: String, val address: Address?)   
class Person(val name: String, val company: Company?)    

fun printShippingLabel(person: Person) {
    val address = person.company?.address?.country 
        ?: throw IllegalArgumentException("No address")
    with(address) {
        println(streetAddress)
        println("$zipCode $city, $country")
    }    
}

fun main() {
    val address = Address("Elsestr.47", 80687, "Munich", "Germany")   
    val jetbrains = Company("JetBrains", address)
    val person = Person("Dmitry", jetbrains)
    printShippingLabel(person)   
    printShippingLabel(Person("Alex", null))   
}
>>> Elsestr.47
>>> 80867 Munich, Germany
>>> java.lang.IllegalArgumentExcpetion: No address
```
모든 정보가 제대로 있으면 주소를 출력하지만,  
주소가 없으면 그냥 `IllegalArgumentExcpetion`을 던지는 대신에 의미있는 오류를 발생시킨다.  
그리고 `with()`를 이용해서 `Address`를 4번 반복하지 않았다.   
  
# 안전한 타입 캐스트: as?   








널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.       ㅇㅢ미 
널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.       

