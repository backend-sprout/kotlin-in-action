코드 다듬기: 로컬 함수와 확장   
=======================    
많은 개발자들이 좋은 코드의 중요한 특징 중 하나가 중복이 없는 것이라 믿는다.                  
그래서 그 원칙에는 반복하지 말라 `DRY 원칙`이라는 이름도 붙어있다.                 
하지만 자바 코드를 작성할 때는 DTY원칙을 피하기는 쉽지 않다.                 
많은 경우 메서드 추출 리팩토링을 적용해서 긴 메서드를 부분부분 나눠서 각 부분을 재활용할 수 있다.          
              
하지만 코드를 리팩토링하면 클래스 안에 작은 메서드가 많아지고                
각 메서드 사이의 관계를 파악하기 힘들어서 코드를 이해하기 더 어려워질 수도 있다.                
      
리팩토링을 진행해서 추출한 메서드를 별도의 내부 클래스 안에 넣으면 코드를 깔끔하게 조직할 수는 있지만,         
그에 따른 불필요한 준비 코드가 늘어난다.         
              
코틀린에는 더 깔끔한 해법이 있다.             
코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다.           
그렇게 하면 문법적인 부가 비용을 들이지 않고도 깔끔하게 코드를 조직할 수 있다.         
          
흔히 발생하는 코드 중복을 로컬 함수를 통해 어떻게 제거할 수 있는지 살펴보자      

```kt
class User(val id: Int, val name: String, val address: String)  
      
fun saveUser(user: User) {
    if(user.name.isEmpty()) {
        throw IllegalArgumentException("Can't save user ${user.id}: empty Name")
    }
    if(user.address.isEmpty()) {
        throw IllegalArgumentException("Can't save user ${user.id}: empty Address")
    }
    // user에 데이터 베이스를 저장한다.      
}
saveUser(User(1, "", ""))
>>> java.lang.IllegalArgumentException: Can't save user 1: empty Name
```
클래스가 사용자의 필드를 검증할 때 필요한 여러 경우를 하나씩 처리하는 메서드로 넘쳐나기를 바라지는 않을 것이다.              
이런 경우를 하나씩 처리하는 메서드로 넘쳐나기를 바라지 않을 것이다.                
이런 경우 검증 코드를 로컬 함수로 분리하면 중복을 없애는 동시에 코드 구조를 깔끔하게 유지할 수 있다.             

```kt
class User(val id:Int, val name: String, val address: String)

fun saveUser(user: User) {
    fun validate(user: User, value: String, fieldName: String) {
        if (value.isEmpty()) {
            throw IllegalArgumentException("Can't save user ${user.id}: empty $fieldName")
        }
    }
}
```


















