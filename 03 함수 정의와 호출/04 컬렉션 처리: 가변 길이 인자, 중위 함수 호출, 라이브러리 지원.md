컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원
==============================================

* `varag 키워드`를 사용하면 호출시 **인자 개수가 달라질 수 있는 함수를 정의할 수 있다.**      
* `중위 함수 호출 구문`을 사용하면 **인자가 하나뿐인 메서드를 간편하게 호출할 수 있다.**    
* `구조 분해 선언`을 사용하면 **복합적인 값을 분해해서 여러 변수에 나눠 담을 수 있다.**   
   
# 자바 컬렉션 API 확장 

```kt
val strings: List<String> = listOf("first", "second", "fourteenth")   
// 호출문 
stirngs.last()
>>> fourtennth
```
```kt
val numbers: Collection<Int> = setOf(1, 2, 3)
// 호출문 
numbers.max()
>> 3
```   
위와 같이 코틀린 API는 자바에 비해 확장 된 기능을 제공해주고 있다.            
그리고 이 같은 기능이 동작할 수 있었던 이유는 `last()`, `max()` 모두 확장 함수였기 때문이다.             
   
```kt
fun <T> List<T>.last(): T { /* 마지막 원소를 반환함 */ }
fun Collection<Int>.max(): Int { /* 컬렉션의 최대값을 반환함 */ }
```

# 가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의
리스트를 생성하는 함수를 호출할 때 원하는 만큼 많이 원소를 전달할 수 있다.  

```kt
fun listOf<T>(vararg values: T): List<T> { ... }
```
```kt
val list = listOf(2, 3, 5, 7, 11)
```
자바의 `...`인 길이 인자와 비슷한 역할을 한다.        
코틀린에서는 `...` 대신 앞에 `vararg` 변경자를 붙인다.      

큰 차이점으로 배열을 넘길때 풀어 해쳐서 입력해야한다는 점이다.   

```kt
fun main(args: Array<String>) {
    val list = listOf("args: ", *args) // 스프레드 연산자가 배열의 내용을 펼쳐준다.    
    println(list)  
}
```
자바 같은 경우, 가변 인자를 사용하면 배열을 그대로 넣어주면 되지만      
코틀린 같은 경우, 가변 인자를 사용하면 `*`스프레드 연산자로 배열의 내용을 펼쳐서 넣어야한다.       
스프레드 연산자를 사용하면 배열에 들어있는 값과 다른 값을 함께 써서 함수를 호출할 수 있음을 보여준다.     

# 값의 쌍 다루기: 중위 호출과 구조 분해 선언
```kt
val map = mapOf(1 to "one", 7 to "seven", 53 to "fifty-three")
```
`to`라는 키워드는 사실 코틀린의 키워드가 아니다.        
이 코드는 **중위 호출이라는 특별한 방식으로 to라는 일반 메서드를 호출한 것이다.**          
   
중위 호출시에는 **수신 객체와 유일한 메서드 인자 사이에 메서드 이름을 넣는다.** 

```kt
1.to("one") // "to" 메서드를 일반적인 방식으로 호출함    
1 to "one"  // "to" 메서드를 중위 호출 방식으로 호출함     
```
**인자가 하나뿐인 일반 메서드나 인자가 하나뿐인 확장 함수에 중위 호출을 사용할 수 있다.**      
단, 함수를 중위 호출에 사용하고 싶다면 **infix 변경자를 함수 선언 앞에 추가해야한다.**      

```kt
infix fun Any.to(other: Any) = Pair(this, other)
```
**`to()`는 Pair 인스턴스를 반환한다.(mapOf는 Pair를 통해 인스턴스를 생성하고 있었던 것이다.)**          
Pair는 코틀린 표준 라이브러리 클래스로, 두 원소로 이뤄진 쌍을 표현한다.(to는 실제로 제네릭함수다 위는 생략함)   
   
```kt   
val (number, name) = 1 to "one"
```       
Pair 값은 위와 같이 초기화할 수 있으며 이런 기능을 **구조 분해 선언**이라고 부른다.          
    
[#](#)   
 
Pair 인스턴스 외 다른 객체에도 구조 분해를 적용할 수 있다.(예를 들어 key와 value라는 두 변수를 맵의 원소를 사용해 초기화 가능)   
루프에서도 구조 분해 선언을 활용할 수 있다. 

```kt
for ((index, element) int collection.withIndex()) { // 사실 이게 구조분해 선언이었다.   
    println("$index: #element")
}
```
`withIndex()`를 구조 분해 선언과 조합하면 컬렉션 원소의 인덱스와 값을 따로 변수에 담을 수 있다.        

참고로 `to()`는 확장 함수이다.      
`to()`를 사용하면 타입과 관계없이 임의의 순서쌍을 만들 수 있다.     
이는 `to()`의 수신 객체가 제네릭하다는 뜻이다.   

```kt
fun<K, V> mapOf(vararg values: Piar<K, V>): Map<K, V>
```
`mapOf()`는 `vararg`키워드가 붙었기 때문에 원하는 개수만큼 인자를 전달할 수 있다.     
하지만 mapOf의 경우에는 각 인자가 키와 값으로 이뤄진 순서쌍이어야 한다.     
