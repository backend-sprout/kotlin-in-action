컬렉션과 배열
==============
이미 컬렉션 API를 사용하는 다양한 예제를 봤다.   

# 널 가능성과 컬렉션  
컬렉션 안에 널 값을 넣을 수 있는지 여부는 어떤 변수의 값이 널이 될 수 있는지 여부와 마찬가지로 중요하다.          
컬렉션에서는 제네릭 타입 안에 `?`을 입력하면 널을 입력할 수 있는 컬렉션이 된다.    
    
```kt
fun readNumbers(reader: BufferedReader): List<Int?> {
    val result = ArrayList<Int?>()
    for(line in reader.lineSequence()) {
        try {
            val number = line.toInt()
            result.add(number)
        } catch(e: NumberFormatException) {
            result.add(null)
        }
    }
    return result
}
```
    
`변수 타입의 널 가능성`과 `타입 파라미터로 쓰이는 타입의 널 가능성`에는 약간의 차이가 있다.  

[#](#)  

* `List<Int?>`는 리스트 자체는 항상 널이 아니지만 리스트에 들어있는 각 원소는 널이 될 수 있다.        
* `List<Int>?`의 경우 리스트를 가리키는 변수에는 널이 들어갈 수 있지만, 리스트 안에는 널이 아닌 값만 들어간다.    
   
경우에 따라 `널이 될 수 있는 값으로 이뤄진 널이 될 수 있는 리스트`인 `List<Int?>?`로 정의할 수 있다.       
이런 리스트를 처리할 때는 변수에 대해 널 검사를 수행한 다음에 그 리스트에 속한 모든 원소에 대해 다시 널 검사를 수행한다.    
  
널이 될 수 있는 값으로 이뤄진 컬렉션으로 널 값을 걸러내는 경우가 자주 있어서       
코틀린 표준 라이브러리는 그런 일을 하는 filterNotNull 이라는 함수를 제공한다.   

```kt
fun addValidNumbers(numbers: List<Int?>){
    val validNumbers = numbers.filterNotNull()
    println("Sum of valid numbers: ${validNumbers.sum()}")
    println("Invalid numbers: ${numbers.size - validNumbers.size}")
}
```
`filterNotNull()`은 컬렉션 안에 널이 들어있지 않음을 보장해준다.    

# 읽기 전용과 변경 가능한 컬렉션 




    


