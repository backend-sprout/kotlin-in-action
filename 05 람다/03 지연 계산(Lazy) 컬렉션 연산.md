지연 계산(Lazy) 컬렉션 연산
=============================    
**`map()`, `filter()` 와 같은 함수들은 결과 컬렉션을 즉시 생성한다.**           
이는 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다.         
**시퀀스 Sequence**를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.      

```kt
people.map(Person::name).filter { it.startsWith("A") }
```

코틀린 표준 라이브러리 참조 문서에는 filter와 map이 리스트를 반환한다고 써 있다.     
즉, 한 리스트는 filter의 결과를 담고, 다른 하나는 map 의 결과를 담는다.      
이는 이 연쇄 호출이 리스트를 2개 만든다는 뜻이다.(각각의 연산마다 리스트 새로 만든다.)      
만약, 원소가 수백만 개가 되면 훨씬 효율이 급격하게 떨어질 것이다.      

```kt
people.asSequence()                   // 원본 컬렉션을 시퀀스로 변환
    .map(Person::name)                // 시퀀스도 컬렉션과 똑같은 API 제공
    .filter { it.startsWith("A") }    // 시퀀스도 컬렉션과 똑같은 API 제공
    .toList()                         // 결과 시퀀스를 다시 컬렉션으로 변환한다.    
```
연산을 효율적으로 만들기 위해서는 각 연산이 컬렉션을 직접 사용하는 대신 시퀀스를 사용하게 만들어야한다.      
중간 결과를 저장하는 컬렉션이 생기지 않기 때문에 원소가 많은 경우 성능이 눈에 띄게 좋아진다.     
  
코틀린 지연 계산 시퀀스는 Sequence 인터페이스에서 시작한다.       
이 인터페이스는 **단지 한 번 에 하나씩 열거될 수 있는 원소의 시퀀스를 표현할 뿐이다.**          
Sequence 안에는 iterator라는 단 하나의 메서드가 존재하는데 이를 통해 시퀀스로부터 원소값을 얻을 수 있다.    
           
Sequence 인터체이스의 강점은 그 인터페이스 위에 구현된 연산이 계산을 수정하는 방법 때문에 생긴다.         
시퀀스의 원소는 필요할 때 비로소 계산된다.          
따라서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서 효율적으로 계산을 수행할 수 있다.        
(마지막에 연산 모아서 한번에 처리한다는 뜻인가?)     
   
`asSequence()` 확장 함수를 호출하면 어떤 컬렉션이든 시퀀스로 바꿀 수 있다.       
시퀀스를 리스트로 만들 때는 `toList()`를 사용한다.      
   
시퀀스는 컬렉션보다 장점은 있지만, 이는 특정 상황에서만 그런 것이다.     
만약. 시퀀스의 원소를 인덱스를 사용해 접근하고자 한다면 결구겡는 시퀀스를 리스트로 변환해야한다.      

```  
큰 컬렉션에 대해서 연산을 연쇄시킬 때는 시퀀스를 사용하는 것을 규칙으로 삼아라      
중간 컬렉션을 생성함에도 불구하고 코틀린에서 즉시 계산 컬렉션에 대한 연산이 더 효율적인 이유를 설명한다.      
하지만 컬렉션에 들어있는 원소가 많으면 중간 원소를 재배열 하는 비용이 커지기 때문에 지연 계산이 더 낫다.  
```

시퀀스에 대한 연산을 지연 계산하기 때문에     
정말 계산을 실행하게 만들려면 최종 시퀀스의 원소를 하나씩 이터레이션 하거나     
최종 시퀀스를 리스트로 변환해야한다.   

# 시퀀스 연산 실행: 중간 연산과 최종 연산  
시퀀스에 대한 연산은 아래 2가지로 나뉜다.    

* 중간 연산
* 최종 연산

중간 연산은 다른 시퀀스를 반환한다.   
그 시퀀스는 최초 시퀀스의 원소를 변환하는 방법을 안다.   
  
최종 연산은 결과를 반환한다.      
결과는 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터      
일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자 또는 객체다.     

[#](#)   

**시퀀스의 중간 연산은 항상 지연 계산된다.**     

```kt
listOf(1, 2, 3, 4).asSequence()
        .map { print("map($it) "); it * it } // it * it 반환
        .filter { print("filter($ir) "); it % 2 == 0 }
```  
위 코드는 최종 연산이 없고 중간 연산만 있는 코드다.      
이 코드를 실행하면 아무 내용도 출력되지 않는다.         
이는 `map()`과 `filter()` 변환이 늦쳐줘 결과를 얻을 필요가 있을 때 적용된다는 뜻이다.   

```kt
listOf(1, 2, 3, 4).asSequence()
        .map { print("map($it) "); it * it } // it * it 반환
        .filter { print("filter($ir) "); it % 2 == 0 }
        .toList()
        
>>> map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)
```
최종 연산을 호출하면 연기됐던 모든 계산이 수행된다.      

직접 연산을 구현한다면 `map()` 함수를 각 원소에 대해 먼저 수행해서 새 시퀀스를 얻고,      
그 시퀀스에 대해 다시 `filter()`를 수행할 것이다.(컬렉션 API 들은 이 같이 동작을 한다.)      
**하지만 시퀀스에 대한 map과 filter는 그렇지 않다.**        
   
시퀀스의 경우 모든 연산은 각 원소에 대해 순차적으로 적용된다.      
즉, 첫번째 원소가 처리되고 다시 두 번째 원소가 처리되며, 이런 처리가 각각의 모든 원소에 적용된다.     
    
따라서 원소에 연산을 차례대로 적용하다가 결과가 얻어지면        
그 이후의 원소에 대해서는 변환이 이뤄지지 않을 수도 있다.        




     










 


