코틀린의 원시 타입 
==========

# 원시 타입: Int, Boolean 등   
자바는 원시 타입과 참조 타입을 구분한다.        
원시 타입의 변수에는 그 값이 직접 들어가지만, 참조 타입의 변수에는 메모리상의 객체 위치가 들어간다.        

코틀린은 원시 타입과 래퍼 타입을 구분하지 않으므로 항상 같은 타입을 사용한다.   

```kt
val i: Int = 1
val list: List<Int> = listOf(1, 2, 3)
```
래퍼 타입을 따로 구분하지 않으면 편리하다.      
더 나아가 코틀린에서는 숫자 타입 등 원시 타입의 값에 대해 메서드를 호출할 수 있다.     
`coercIn()`을 사용하면 특정 범위로 수를 제한할 수 있다.   
   
```kt
fun showProgress(progress: Int) {
    val percent = progress.coercIn(0, 100)
    println("We're ${percent} % done!")
}
fun main() {
    showProgress(146)
}
>>> We're 100 % done!
```

**원시 타입과 참조 타입이 같다면 코틀린이 그들을 항상 객체로 표현하는 것일까? 🤔**       
항상 객체로 표현한다면 비효율적이겠지만 코틀린은 그러지 않는다.   
  
실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현된다.        
대부분의 경우 코틀린의 Int 타입은 자바 int 타입으로 컴파일 된다.          
이런 컴파일이 불가능한 경우는 컬렉션과 같이 제네릭 클래스를 사용하는 경우이다.      
즉, Int 타입을 컬렉션의 타입 파라미터로 넘기면 그 컬렉션에는 Integer 객체가 들어간다.   
      
**자바 원시 타입에 해당하는 코틀린 타입**      
* 정수 타입: Byte, Shor, Int, Long
* 부동소수점 수 타입: Float, Double 
* 문자 타입: Char
* 불리언 타입: Boolean 

Int와 같은 코틀린 타입에는 널 참조가 들어갈 수 없기 때문에 쉽게 그에 상응하는 원시 타입으로 컴파일할 수 있다.   
마찬가지로 반대로 자바 원시 타입의 값은 결코 널이 될수 없으므로    
자바 원시 타입을 코틀린에서 사용할 때도 널이 될 수 없는 타입으로 취급할 수 있다.     

# 널이 될 수 있는 원시 타입: Int?, Boolean? 등   
null 참조를 자바의 참조 타입의 변수에만 대입할 수 있기 때문에        
널이 될 수 있는 코틀린 타입은 자바 원시 타입으로 표현할 수 없다.        
따라서 **코틀린에서 널이 될 수있는 원시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일된다.**        
  
```kt
data class Person(val name: String, val age: Int? = null) {
    fun isOlderThan(other: Person): Boolean? {
        if(age == null || other.age == null) {
            return null
        }
        return age > other.age
    }
}
```
널이 될 가능성이 있으므로 `Int?`타입의 두 값을 직접 비교할수는 없다.(널인지 검사후에 가능)     
    
Person 클래스에 선언된 age 프로퍼티의 값은 자바에서는 `Integer`로 저장된다.      
하지만, 그런 자세한 사항은 자바에서 가져온 클래스를 다룰 때만 문제가 된다.      
코틀린에서 적절한 타입을 찾으려면 그 변수나 프로퍼티에 널이 들어 갈 수 있는지만 고민하면 된다.   

```kt
val listOfInts = listOf(1, 2, 3)
```
앞에서 이야기한대로 제네릭 클래스의 경우 래퍼 타입을 사용한다.  
위 코드는 null값이나 null이 될수 잇ㄴ느 타입이 아님에도 래퍼 클래스로 이뤄진 리스트다.   
  
이렇게 컴파일하는 이유는 자바가상서밋ㄴ에서 제네릭을 구현하는 방법 때문이다.       
JVM은 타입 인자로 원시 타입을 허용하지 않는다.       
따라서 자바나 코틀린 모두에서 제네릭 클래스는 항상 박스 타입을 사용해야 한다.    

# 숫자 변환 
코틀린과 자바의 가장 큰 차이점 중 하나는 숫자를 변환하는 방식이다.      
코틀린은 타입의 숫자를 다른 타입의 숫자로 자동 변환하지 않는다.        
결과 타입이 허용하는 숫자 범위가 원래 타입의 범위보다 넓은 경우조차도 자동 변환은 불가능하다.     

```kt
val i = 1
val l: Long = i
```
대신 직접 변환 메서드를 호출해야한다.  

```kt
val i = 1
val l: Long = i.toLong()
```
   
코틀린은 모든 원시 타입에 대한 변환 함수를 제공한다.      
그런 변환 함수의 이름은 주로 `toInt()`, `toByte()`와 같은 `to~()`와 같다.       
더 넓은 범위의 타입은 물론, 더 좁은 범위의 타입으로도 변환하는 메서드가 존재한다.   
   
코틀린은 연산시 혼란을 막기 위해 타입 변환을 명시하기로 결정했다.    
자바에서는 `new Integer(42).equals(new Long(42))의 결과는 false가 나온다.    

```kt
val x = 1
println(x.toLong() in listOf(1L, 2L, 3L))
>>> true
```
코드에서 동시에 여러 숫자 타입을 사용하려면     
예상치 못한 동작을 피하기 위해 각 변수를 명시적으로 변환해야한다.     

```
// 원시타입 리터럴 
코틀린은 소스코드에서 단순한 10진수 외에 다음과 같은 숫자 리터럴을 허용한다.  

* L 접미사가 붙은 Long 타입 리터럴: 123L 
* 표준 부동소수점 표기법을 사용한 Double 타입 리터럴: 0.12 
* f나 F접미사가 붙은 Float타입 리터럴: 123.4f
* 0x나 0X 접두사가 붙은 16진 리터럴: 0xCAFEBABE 
* 0b나 0B 접두사가 붙은 2진 리터럴: 0b000001

코틀린 1.1부터는 숫자 리터럴 중간에 밑줄을 넣을수도 있다.  
```
숫자 리터럴을 사용할때 보통 변화너 함수를 호출할 필요가 없다.      
상수 뒤에 타입을 표현하는 문자를 붙이면 변환이 필요 없다.           
또한 직접 변환하지 않아도 숫자 리터럴을 타입이 알려진 변수와 대입하거나      
함수에게 인자로 넘기면 컴파일러가 필요한 변환을 자동으로 넣어준다.    

추가로 산술 연산자는 적당한 타입의 값을 받아들일 수 있게 이미 오버로드되어 있다.   

```kt
fun foo(l: Long) = println(1)

fun main() {
    val b: Byte = 1
    val l = b + 1L
    foo(42)
}
>>> 42
```
코틀린 산술 연산자에도 숫자 연산시 값넘침이 발생할 수 있다.      
하지만, 코틀린은 값 넘침을 검사하느라 추가 비용을 들이지는 않는다.    

```
// 문자열을 숫자로 변환하기  
코틀린 표준 라이브러리는 문자열을 원시타입으로 변환하는 여러 함수를 제공한다.  

println("42".toInt())
>>> 42

이런 함수는 문자열의 내용을 각 원시 타입을 표기하는 문자열로 파싱한다.   
파싱에 실패하면 NumberFormatException이 발생한다.   
```  

# Any, Any? 최상위 타입  
자바에서의 Object 클래스와 같은 최상위 클래스가        
코틀린에서는 `Any`와 `Any?`가 그 역할을 맡고 있다.      

```kt
val answer: Any = 42
```    
 
단, 자바에서의 Object는 원시타입을 제외한 참조 타입에서만 최상위 클랫스인 반면에     
코틀린의 `Any`와 `Any?`는 원시타입 Int, Long과 같은 타입들의 최상위 타입이다.    
  
`Any`는 널이 될 수 없는 타입임을 유의하자.        
널을 포함하는 모든 값을 대입할 변수를 선언하려면 `Any?` 타입을 사용해야 한다.     

내부에서 Any타입은 Object에 대응한다.   
자바 메서드에서 Object를 인자로 받거나 반환하면 코틀린에서는 Any로 그 타입을 취급한다.(Any!)   
코틀린 함수가 Any를 사용하면 자바 바이트코드의 Object로 컴파일 된다.    

참고로 `toString()`, `equals()`, `hashCode()`와 같은 메서드는 Any에서 비롯된 것이다.   
  
# Unit 타입: 코틀린의 void      
**코틀린의 Unit 타입은 자바 void와 같은 기능을 한다.**        
관심을 가질 만한 내용을 전혀 반환하지 않는 함수의 반환 타입으로 Unit을 쓸 수 있다.       

```kt
fun f(): Unit { ... }  
// fun f() { ... }
```
이는 반환 타입 선언 없이 정의한 블록이 본문인 함수와 같다.   

대부분의 경우 void와 Unit의 차이를 알기는 쉽지 않다.   

코틀린 함수의 반환 타입이 Unit이고 그 함수가 제네릭 함수를 오버라이드하지 않았다면 내부에서 자바 void 함수로 컴파일된다.     
이런 코틀린 함수를 자바에서 오버라이드하는 경우 void를 반환 타입으로 해야한다.     
 
**그렇다면 차이점은 무엇일까? 🤔**       
Unit은 모든 기능을 갖는 일반적인 타입이며, void와 달리 Unit을 타입인자로도 쓸 수 있다.    
Unit 타입에 속한 값은 단 하나뿐이며, 그 이름도 Unit이다.         
Unit타입의 함수는 Unit 값을 묵시적으로 반환한다.       
이 두 특성은 제네릭 파라미터를 반환하는 함수를 오버라이드 하면서 반환 타입으로 Unit을 쓸 때 유용하다.     

```kt
interface Processor<T> {
    fun process(): T
}

class NoResultProcessor: Processor<Unit> { // 타입인자로 사용이 가능하다.   
    override fun process() {
        // 업무 처리 코드, return 명시할 필요는 없다.  
    }
}
```
인터페이스의 시그니처는 process 함수의 어떤 값을 반환하라고 요구한다.    
특정 타입을 선언했을 때는 그 타입에 맞는 값을 반환해야하지만, Unit 타입을 선언했을 때는 반환을 넣지 않아도 된다.    
(컴파일러가 묵시적으로 return Unit 을 넣어준다.)   

타입 인자로 `값 없음`을 표현하는 문제를 자바에서 어떻게 코틀린과 같이 깔끔하게 해결할 수 있을지 생각해보자      
별도의 인터페이스를 사용해 값을 반환하는 경우와 값을 반환하지 않는 경우를 분리하는 방법도 있다.   
반환형을 Void 클래스를 선언하는 방법도 있지만 결국에는 `return null`을 명시해야한다.  

함수형 프로그래밍에서 전통적으로 Unit은 단 하나의 인스턴스만 갖는 타입을 의미해왔고      
바로 그 유일한 인스턴스의 유무가 자바의 void와 코틀린 Unit을 구분하는 가장 큰 차이다.   

# Nothing 타입: 이 함수는 결코 정상적으로 종료되지 않는다.   
코틀린에서는 결코 성공적으로 값을 돌려주는 일이 없는 즉, `반환값`이라는 개념 자체가 없는 함수가 일부 존재한다.       

예를 들어, 테스트 라이브러리들은 fail이라는 함수를 제공하는 경우가 많다.     
fail은 특별한 메시지가 들어있는 예외를 던져서 현재 테스트를 실패시킨다.          
다른 예로 무한루프를 도는 함수도 결코 값을 반환하며, 정상적으로 끝나지는 않는다.    

그런 함수를 호출하는 코드를 분석하는 경우 함수가 정상적으로 끝나지 않는다는 사실을 알면 유용하다.     
그런 경우를 표현하기 위해 코틀린에는 Nothing이라는 특별한 변환 타입이 있다.    

```kt
fun fail(message: String): Nothing {
    throw IllegalStateException(message)
}
fun main() {
    fail("Error occured")
}
>>> java.lang.IllegalStateException: Error occured  
```  
Nothing 타입은 아무 값도 포함하지 않는다.       
따라서 Nothing은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다.         
그 외의 다른 용도로 사용하는 경우 Nothing 타입의 변수를 선언하더라도      
그 변수에 아무 값도 저장할 수 없으므로 아무 의미도 없다.    

Nothing을 반환하는 함수를 엘비스 연산자의 우항에 사용해서 전제 조건을 검사할 수도 있다.   

```kt
val address = company.address ?: fail("No address")
println(address.city)
```
이 예제는 타입 시스템에서 Nothing이 얼마나 유용한지 보여준다.     
컴파일러는 Nothing이 반환 타입인 함수가 결코 정상 종료되지 않음을 알고 그 함수를 호출하는 코드를 분석할 때 사용한다.     
앞의 예제에서 컴파일러는 company.address가 널인 경우 엘비스 연산자의 우항에서 예외가 발생한다는 사실을 파악하고         
address의 값이 널이 아님을 추론할 수 있다.     
