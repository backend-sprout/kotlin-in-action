컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임
==========================================
자바에서는 equals, hashCode, toString 등의 메서드를 구현해야한다.            
그리고 이런 메서드들은 보통 비슷한 방식으로 기계적으로 구현 가능하다.              
코틀린 컴파일러는 특정 키워드를 통해 이런 메서드를 기계적으로 생성하는 작업을 진행해준다.       

# 모든 클래스가 정의해야 하는 메서드   
코틀린 클래스도 toString, equals, hashCode 등을 오버라이드 할 수 있다.   

```kt
class Client(val name: String, val pstalCode: Int)
```

## 문자열 표현: toString()    
코틀린의 모든 클래스도 인스턴스의 문자열 표현을 얻을 방법을 제공해야한다.      
주로 디버깅과 로깅 시 이 메서드를 사용한다.     

```kt
class Client(val name: String, val postalCode: Int) {
    override fun toString() = "Client(name='$name', postalCode=$postalCode)"
}
```
이렇게 문자열 표현을 쓴다면, 현재 객체의 상태가 어떤지 쉽게 파악할 수 있다.   

## 객체의 동등성: equals()  
동일 클래스를 기반으로 생성된 서로 다른 두 객체가     
내부에 동일한 데이터를 포함하는 경우 이를 동등한 객체로 간주해야할 수 도 있다.       
   
```
// 동등성 연산에 == 를 사용함   
자바에서는 ==를 원시 타입과 참조 타입을 비교할 때 사용한다.       
원시 타입의 경우 == 는 두 피연산의 값이 같은지 비교한다.(동등성)        
반면에 참조 타입의 경우 == 는 두 피연산자의 주소가 같은지 비교한다.(참조 비교)        

코틀린에서는 == 연산자가 두 객체를 비교하는 기본적인 방법이다.   
==는 내부적으로 equals를 호출해서 객체를 비교하기 때문이다.   
따라서 클래스가 equals를 오버라이드하면 == 를 통해 안전하게 그 클래스의 인스턴스를 비교할 수 있다.      
참조 비교를 위해서는 === 연산자를 지원한다. 
```
   
일반적으로 객체는 주소값 비교를 진행하기 때문에 내부에 동등한 값을 가지더라도 서로 다른 종류로 인식한다.     
  
```kt
class Client(val name: String, val postalCode: Int) {
    override fun equals(other: Any?): Boolean {                       // Any는 Object 대응 클래스(최상위), Nullable 검사를 한다.  
        if(other == null || other !is Clinet) return false            // is -> 타입 검사 
        return name == other.name && postalCode == other.postalCode   // 두 객체의 프로퍼티 값이 서로 같은지 검사한다.   
    }
}
```

코틀린에서는 override 변경자가 필수여서 다른 메서드 시그니처를 작성할 수는 없다.       
그래서 equals를 오버라이드하고 나면 프로퍼티의 값이 모두 같은 두 고객 객체는 동등하리라 예상할 수 있다.          
그러나 hash 기반으로 동작하는 로직에 대해서는 동등하다고 판단하지 않을 수 있으니 hashCode에 대해서 알아보자      

## 해시 컨테이너: hashCode()     
JVM 언어에서는 `equals()가 true를 반환하는 두 객체는 반드시 같은 hashCode()를 반환해야한다.`라는 제약이 있다.      
HashSet은 원소를 비교할 때 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 해시 코드가 같은 경우에만 실제 값을 비교한다.   
   
```kt
val processed = hashSetOf(Client("오현식", 4122))
println(processed.contains(Client("오현식", 4122))
>>> false  
```
해시코드는 기본적으로 객체의 주소값 기반으로 생성되기 때문에 오버라이드 하지 않을 경우 대부분 다르다.    
그렇기 때문에 위와 같은 예제에서는 false 란 값이 호출되고 있음을 알 수 있다.    

```kt
class Client(val name: String, val postalCode: Int) {
    ... // equals 생략 
    override fun hashCode(): Int {
        var result = name.hashCode()
        result = 31 * result + postalCode
        return result
    }
}
```
hashCode를 오버라이드함으로써 hash에 관한 동등성 비교에서의 문제가 해결되었다.     
다시 한번 언급하지만 완전한 동등성을 보장하려면 equals랑 hashCode 둘 모두 오버라이드해줘야 한다.       
  
# 데이터 클래스: 모든 클래스가 정의해야 하는 메서드 자동 생성        













