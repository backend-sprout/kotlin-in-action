클래스 계층 정의
=============
> 코틀린에서 클래스 계층을 정의하는 방식과 자바 방식을 비교한다.       
> 그 후 코틀린의 가시성과 접근 변경자에 대해 살펴본다.         
  
코틀린 가시성/접근 변경자는 자바와 비슷하지만, 아무것도 지정하지 않은 경우 기본 가시성은 다르다.      
또한 코틀린에서 새로 도입한 sealed 변경자에 대해 설명한다.(sealed는 클래스 상속을 제어한다.)       
   
# 코틀린 인터페이스   
코틀린 인터페이스는 자바8 인터페이스와 비슷하다.     
코틀린 인터페이스 안에는 추상 메서드뿐 아니라 구현이 있는 메서드도 정의할 수 있다.(자바의 디폴트 메서드)          
다만 인터페이스에는 아무런 상태도 들어갈 수 없다.(인스턴스 변수)    

```kt
interface Clickable {
    fun click()
}
```
click() 추상 메서드를 정의한 인터페이스다.     

```kt
class Button: Clickable {
    override fun click() = println("I was clicked")
}
```
```kt
Button().click()
>>> I was clicked   
```  
코틀린에서는 `: 상위 타입`을 붙이는 것으로 상속과 구현 모두 지원한다.           
이외에 비슷한 점으로 자바처럼 단일 상속, 다중 구현을 지원한다.          

참고로 자바의 `@Override` 대신에 `override`변경자를 사용하여 프로퍼티나 메서드를 오버라이드한다.   
그리고 이러한 변경자는 생략 불가능하므로 꼭 사용해야 한다.(실수를 방지해준다.)   

```kt
interface Clickable {
    fun click()                               // 일반 추상 메서드 
    fun showOff() = println("I'm clickable!") // 디폴트 구현이 있는 메서드 
}
```   
인터페이스 메서드도 디폴트 구현을 제공할 수 있다.      
이 경우 **자바와 다르게 `default`키워드를 붙이지 않고 그냥 정의하기만 하면 된다.**        

인터페이스 구현 클래스는 `click()`에 대한 메서드 정의는 필수지만,   
`showOff()`에 대한 오버라이딩은 선택적이다.        
     
```kt
interface Focusable {
    fun setFocus(b: Boolean) = println("I ${if (b) "got" else "lost"} focus.")
    fun showOff = println("I'm focusable!")
}
```
만약, 동일한 이름을 가진 메서드를 다른 인터페이스에서도 정의했다고 가정하자.    
     
**한 클래스에서 이 두 인터페이스를 함께 구현하면 어떻게 될까? 🤔**          
 






    

