클래스 계층 정의
=============
> 코틀린에서 클래스 계층을 정의하는 방식과 자바 방식을 비교한다.       
> 그 후 코틀린의 가시성과 접근 변경자에 대해 살펴본다.         
  
코틀린 가시성/접근 변경자는 자바와 비슷하지만, 아무것도 지정하지 않은 경우 기본 가시성은 다르다.      
또한 코틀린에서 새로 도입한 sealed 변경자에 대해 설명한다.(sealed는 클래스 상속을 제어한다.)       
   
# 코틀린 인터페이스   
코틀린 인터페이스는 자바8 인터페이스와 비슷하다.     
코틀린 인터페이스 안에는 추상 메서드뿐 아니라 구현이 있는 메서드도 정의할 수 있다.(자바의 디폴트 메서드)          
다만 인터페이스에는 아무런 상태도 들어갈 수 없다.(인스턴스 변수)    

```kt
interface Clickable {
    fun click()
}
```
click() 추상 메서드를 정의한 인터페이스다.     

```kt
class Button: Clickable {
    override fun click() = println("I was clicked")
}
```
```kt
Button().click()
>>> I was clicked   
```  
코틀린에서는 `: 상위 타입`을 붙이는 것으로 상속과 구현 모두 지원한다.           
이외에 비슷한 점으로 자바처럼 단일 상속, 다중 구현을 지원한다.          

참고로 자바의 `@Override` 대신에 `override`변경자를 사용하여 프로퍼티나 메서드를 오버라이드한다.   
그리고 이러한 변경자는 생략 불가능하므로 꼭 사용해야 한다.(실수를 방지해준다.)   

```kt
interface Clickable {
    fun click()                               // 일반 추상 메서드 
    fun showOff() = println("I'm clickable!") // 디폴트 구현이 있는 메서드 
}
```   
인터페이스 메서드도 디폴트 구현을 제공할 수 있다.      
이 경우 **자바와 다르게 `default`키워드를 붙이지 않고 그냥 정의하기만 하면 된다.**        

인터페이스 구현 클래스는 `click()`에 대한 메서드 정의는 필수지만,   
`showOff()`에 대한 오버라이딩은 선택적이다.        
     
```kt
interface Focusable {
    fun setFocus(b: Boolean) = println("I ${if (b) "got" else "lost"} focus.")
    fun showOff = println("I'm focusable!")
}
```
만약, 동일한 이름을 가진 메서드를 다른 인터페이스에서도 정의했다고 가정하자.    
     
**한 클래스에서 이 두 인터페이스를 함께 구현하면 어떻게 될까? 🤔**          
정답은 바로... 어느 쪽도 선택되지 않는다.         
클래스가 구현하는 두 상위 인터페이스에 정의된 showOff() 구현을 대체한        
오버라이딩 메서드를 직접 제공하지 않으면 컴파일 오류가 발생한다.(사실 자바도 똑같다)           

```
The class 'Button' must 
override public open fun showOff() because it inhreits  
many implementations of it.
```
코틀린 컴파일러는 두 메서드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.    

```kt
class Button: Clickable, Focusable {
    override fun click() = println("I was clicked")
    override fun showOff() {        // 시그니처가 같은 멤버 메서드에 대해 둘 이상의 디폴트 구현이 있는 경우 필히 오버라이딩 해야한다.
        super<Clickable>.showOff()  // 상위 타입의 이름을 꺾쇠 <> 사이에 넣어서 super를 지정하면      
        super<Focusable>.showOff()  // 어떤 상위 타입의 멤버 메서드를 특정하여 호출할 수 있다.      
    }
}
```
시그니처가 같은 멤버 메서드에 대해 둘 이상의 디폴트 구현이 있는 경우 필히 오버라이딩 해야한다.          
일반적인 상태에서 상위 타입을 호출하고자 하면 단순히 `super`를 사용하면 된다.            
그러나 둘 이상의 상위 타입이 존재할 경우 `super<상위타입>`을 이용하여 명시적으로 선택할 수 있다.         
단, 이 같은 경우도 상위 타입 메서드를 사용할 경우이지, 새롭게 오버라이딩한다면 굳이 정의할 필요는 없다.    
참고로 자바에서는 `Clickable.super.showOff`, `Focusable.super.showOff`와 같은 방식으로 접근한다.      

```kt
override fun showOff() = super<Clickable>.showOff()    
```
하나의 상위 타입만 사용할 경우라면 위와 같이 작성해도 된다.   

```kt
fun main(args: Array<String>) {
    val button = Button()
    button.showOff()        // I'm clickable! I'm Focusable! 출력
    button.setFocus(true)   // I got focus 출력 
    bostton.click()         // I was clicked 출력
}
```
  
**참고**    
```
코틀린은 자바6와 호환되도록 설계되어 있다. 그렇기 때문에 인터페이스의 디폴트 메소드를 지원하지 않는다.      
따라서 코틀린은 디폴트 메서드가 있는 인터페이스를      
일반 인터페이스와 디폴트 메서드 구현이 정적 메서드로 들어있는 클래스를 조합해 구현한다.     
인터페이스에는 메서드 선언만 들어가며, 인터페이스와 함께 생성되는 클래스에는 모든 디폴트 메서드 구현이 정적 메서드로 들어간다.      
그러므로 디폴트 인터페이스가 포함된 코틀린 인터페이스를 자바 클래스에서 상속해 구현하고 싶다면     
코틀린에서 메서드 본문을 제공하는 메서드를 포함하는 모든 메서드에 대한 본문을 작성해야한다.    
(즉, 자바에서는 코틀린의 디폴트 메서드를 알 수 없다.)   
```

# open, final, abstract 변경자: 기본적으로 final
**취약한 기반 클래스**는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경하면서 깨져버린 경우에 생긴다.       
즉, 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면      
그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메서드를 오버라이드 할 위험이 있다.       
모든 하위 클래스를 분석하는 것은 불가능하므로 기반 클래스를 변경하는 경우        
하위 클래스의 동작이 예기치 않게 바뀔수도 있다는 면에서 기반 클래스는 취약하다.       

**즉, 상속을 막지 않으면 하위 클래스에서 언제든지 상속받아서 메서드를 맘대로 사용하여 에러를 유발할 수 있다는 점이다.**          
이 문제를 해결하기 위해 `상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라`라고 조언한다.          
이는 하위 클래스에서 오버라이드하게 의도된 클래스와 메서드가 아니라면 모두 final로 만들라는 뜻이다.      
         
**코틀린은 기본적으로 클래스와 메서드에 대해서 final이다.**                 
만약, **하위 클래스에 상속을 지원해주려면 `open 변경자`를 앞에 붙여야 한다.**          
**오버라이드 허용하고 싶은 메서드나 프로퍼티의 앞에도 open 변경자를 붙여야한다.(인터페이스와 같은 추상 메서드 제외)**         

```kt
open class RichButton: Clickable {
    fun disable() {}          // 파이널 함수로 오버라이딩 불가능
    open fun animate() {}     // 열린 함수로 오버라이딩 가능
    override fun click() {}   // 열린 함수로 오버라이딩 메서드는 기본적으로 open이다.   
}
```
별다른 사항은 없고 open함수 오버라이딩 메서드는 기본적으로 open이라는 점만 기억하자.     
만약 그 이후부터 오버라이드를 지원하고 싶지 않으면 `final`을 붙이면 된다.    

```kt
open class RichButton: Clickable {
    final override fun click() {}
}
```
  
**열린 클래스와 스마트 캐스트**     
```
클래스의 기본적인 상속 가능 상태를 final로 함으로써 얻을 수 있는 큰 이익은 다양한 경우에 스마트 캐스트가 가능하다는 점이다.      
스마트 캐스트는 타입 검사 뒤에 '변경 될수 없는 변수'에만 적용이 가능하다.       
클래스 프로퍼티의 경우 val이면서 커스텀 접근자가 없는 경우에만 스마트 캐스트를 사용할 수 있다는 것을 의미한다.        
이 요구 사항은 또한 프로퍼티가 final 이어야만 한다는 뜻이기도 하다.       
프로퍼티가 final이 아니라면 그 프로퍼티를 다른 클래스에서 상속하면서 커스텀 접근자를 정의함으로써 스마트 캐스트의 요구사항이 깨질 수 있다.      
프로퍼티는 기본저긍로 final 이기 때문에 따로 고민할 필요 없이 대부분의 프로퍼티를 스마트 캐스트에 활용할 수 있다.         
이는 코드를 더 이해하기 쉽게 만든다.      
```   

코틀린에서도 클래스에 abstract를 선언하여 추상 클래스를 만들 수 있다.(인스턴스화 불가)         
추상 클래스에는 구현이 없는 추상 멤버가 있기 때문에 하위 클래스에서 그 추상 멤버를 오버라이드해야만 하는게 보통이다.       
**추상 멤버는 항상 열려 있으므로 따로 open을 명시하지 않아도 된다.**     

```
abstract class Animated { // 추상 클래스는 open이며 인스턴스화가 불가능 하다.   
    abstract fun animate() // 추상 함수로, 구현에서 오버라이드 해야 한다.     
    open fun stopAnimating() {} // 추상클래스에 속해도 비추상 메서드는 open을 입력해야 상속된다.   
    fun animateTwice() {} // 추상클래스에 속해도 비추상 메서드는 open을 입력하지 않을 경우 상속되지는 않는다.   
}
```

|변경자|이 변경자가 붙은 멤버는...|설명|
|-----|--------------------|---|
|final|오버라이드 할 수 없다.|클래스 멤버 기본 변경자|  
|open|오버라이드 할 수 있다.|반드시 open을 명시해야 오버라이드할 수 있다.|   
|abstract|반드시 오버라이드 해야 한다.|추상 클래스의 멤버에만 이 변경자를 붙일 수 있다.<br>추상 멤버에는 구현이 있으면 안 된다.|    
|override|상위 클래스나 상위 인스턴스의 멤버를 오버라이드 하는중|오버라이드 하는 멤버는 기본적으로 열려있다.<br>하위 클래스의 오버라이드를 금지하려면 final을 명시해야 한다.|   

위 표는 코틀린의 상속 제어 변경자를 나열한 것이다.       
인터페이스 멤버 같은 경우 `final`, `open`, `abstract`를 사용하지 않는다.(항상 열린 추상 메서드므로)    

# 가시성 변경자: 기본적으로 공개 

가시성 변경자는 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다.     
어떤 클래스의 구현에 대한 접근을 제한함으로써 그 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현을 변경할 수 있습니다.  















    

