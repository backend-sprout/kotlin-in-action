컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원
==============================================

* `varag 키워드`를 사용하면 호출시 **인자 개수가 달라질 수 있는 함수를 정의할 수 있다.**      
* `중위 함수 호출 구문`을 사용하면 **인자가 하나뿐인 메서드를 간편하게 호출할 수 있다.**    
* `구조 분해 선언`을 사용하면 **복합적인 값을 분해해서 여러 변수에 나눠 담을 수 있다.**   
   
# 자바 컬렉션 API 확장 

```kt
val strings: List<String> = listOf("first", "second", "fourteenth")   
// 호출문 
stirngs.last()
>>> fourtennth
```
```kt
val numbers: Collection<Int> = setOf(1, 2, 3)
// 호출문 
numbers.max()
>> 3
```   
위와 같이 코틀린 API는 자바에 비해 확장 된 기능을 제공해주고 있다.            
그리고 이 같은 기능이 동작할 수 있었던 이유는 `last()`, `max()` 모두 확장 함수였기 때문이다.             
   
```kt
fun <T> List<T>.last(): T { /* 마지막 원소를 반환함 */ }
fun Collection<Int>.max(): Int { /* 컬렉션의 최대값을 반환함 */ }
```

# 가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의
리스트를 생성하는 함수를 호출할 때 원하는 만큼 많이 원소를 전달할 수 있다.  

```kt
fun listOf<T>(vararg values: T): List<T> { ... }
```
```kt
val list = listOf(2, 3, 5, 7, 11)
```
자바의 `...`인 길이 인자와 비슷한 역할을 한다.        
코틀린에서는 `...` 대신 앞에 `vararg` 변경자를 붙인다.      

큰 차이점으로 배열을 넘길때 풀어 해쳐서 입력해야한다는 점이다.   

```kt
fun main(args: Array<String>) {
    val list = listOf("args: ", *args) // 스프레드 연산자가 배열의 내용을 펼쳐준다.    
    println(list)  
}
```
자바 같은 경우, 가변 인자를 사용하면 배열을 그대로 넣어주면 되지만      
코틀린 같은 경우, 가변 인자를 사용하면 `*`스프레드 연산자로 배열의 내용을 펼쳐서 넣어야한다.       
스프레드 연산자를 사용하면 배열에 들어있는 값과 다른 값을 함께 써서 함수를 호출할 수 있음을 보여준다.     

# 값의 쌍 다루기: 중위 호출과 구조 분해 선언 
